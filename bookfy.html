<!DOCTYPE html>
<html>
<head>
  <title>Readability playground</title>
  <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js" ></script>
</head>
<body>
  <div id="controls">
    <input id="uri" placeholder="A web article" value="http://coding.smashingmagazine.com/2011/01/12/guidelines-for-responsive-web-design/">
    <button id="uri-action">Go!</button>
  </div>
  <hr>
  <div id="content">
    <!-- content goes here -->
  </div>
  <style type="text/css">
    #uri {
      width: 30em;
    }

    #content {
      margin: 1em;
      font-size: 150%;
    }
  </style>
  <script type="text/javascript">
    /*
      Concerned with retrieving parsable DOM objects for an article
    */
    var readability = {
      extractContent: function(allContent) {
        /* array of all the main content */

        //BUG this is horribly wrong, but will do for now
        return $(allContent).find("p").first().siblings().addBack();
      },
      token: "3f5c9f6c9869dbb23897ffe7c06f79ea4c1f1963",
      apiRoot: "http://readability.com",
      apiCallUrl: function(contentUrl) {
        return readability.apiRoot + "/api/content/v1/parser?url=" + contentUrl + "&token=" + readability.token;
      },
      getContent: function(contentUrl, successFn, errorFn) {
        //FIXME change to map of params
        /* Slurps content from the given url and passes the first element to success */
        var apiCallUrl = readability.apiCallUrl(contentUrl);

        console.log("Trying to load " + apiCallUrl);
        $.ajax({
          url: apiCallUrl,
          dataType: "jsonp",
          success: function(results){
            console.log("Loaded " + results.url);

            var title = $("<h1>").html(results.title);
            var allContent = readability.extractContent($.parseHTML(results.content));

            var combinedArticle = allContent.first().before(title).siblings();

            successFn(combinedArticle.first());
          },
          error: errorFn
        });
      }
    };

    /*
     * Used to flatten a given DOM structure to only contain the bits we think
     * are "important". It's annoying Readability et al don't do this for me...
    */
    var filters = {
      isLeafNodeFilter: function() {
        /* Where 'leaf' means a node filled only with text or 'inline' nodes */

        var inlineDisplays = ['inline', 'table-row', 'table-row-group', 'table-header-group'];

        if ($.inArray($(this).css('display'), inlineDisplays) != -1) {
          return false;
        }

        var isLeafNode = true;
        $(this).children().each(function() {
          if ($.inArray($(this).css('display'), inlineDisplays) == -1) {
            isLeafNode = false;
            return false;
          }
        });

        // Debugging check
        if (isLeafNode && $(this).contents().filter(function() {return this.nodeType == 3}).length != 0) {
          console.log("We're going to lose text with this element!");
          console.log(this);
        }

        return isLeafNode;
      },
    }

    /*
      Concerned with rendering DOM data to the page. Uses the flattener.

      NB: the elements that are rendered to the page are clones of the
      elements referenced in the pointer map. This separation can be confusing.
    */
    var renderer = {
      elementOffPage: function(element) {
        var elBottom = element.offset().top + element.height();
        var screenHeight = $(window).height();
        // console.log("El at " + elBottom + " of " + screenHeight);
        return (elBottom > screenHeight) ? true : false;
      },
      renderCurrentPage: function(pointer) {
        return renderer.renderNextPage({nextPageHead: pointer.pageHead});
      },
      renderNextPage: function(pointer) {
        /* Renders the next page of content */
        $("#content").empty();

        var resultingPointer = {pageHead: pointer.nextPageHead};
        pointer.nextPageHead.nextAll().addBack().each(function() {
          var pageElement = $(this).clone();
          $("#content").append(pageElement);
          if (renderer.elementOffPage(pageElement)) {
            pageElement.remove();
            resultingPointer.nextPageHead = $(this);
            return false;
          }
        });
        return resultingPointer;
      },
      renderPreviousPage: function(pointer) {
        /* Renders the previous page of content */
        $("#content").empty();

        var resultingPointer = {nextPageHead: pointer.pageHead};
        var pageTail = null;
        pointer.pageHead.prevAll().each(function() {
          var pageElement = $(this).clone();

          if (! pageTail) pageTail = pageElement;

          $("#content").prepend(pageElement);
          if (renderer.elementOffPage(pageTail)) {
            pageElement.remove();
            resultingPointer.pageHead = $(this).next();
            return false;
          }
        });
        return resultingPointer;
      }
    };

    $(function() {
      // TODO put this in a better place
      var pointer = {
        // The node at the top of the *current* page
        pageHead: null,
        // The node that will be at the top of the *next* page
        nextPageHead: null
      };

      $("#uri-action").click(function() {
        readability.getContent($("#uri").val(),
          function(contentHeadNode) {
            pointer = renderer.renderCurrentPage({pageHead: contentHeadNode});

            console.log("Initial render complete");
            console.log(pointer);
          },
          function(e) {
            console.log(e)
            alert("Something went wrong, check the console");
          });
      });
      $(document).keydown(function(e) {
        //TODO clean up, switch or something better
        if (e.keyCode == 39) {
          // Right
          pointer = renderer.renderNextPage(pointer);
          console.log("Next page complete");
          console.log(pointer);
        } else if (e.keyCode == 37) {
          // Left
          pointer = renderer.renderPreviousPage(pointer);
          console.log("Previous page complete");
          console.log(pointer);
        }
      });
      $(window).resize(function() {
        //FIXME something (threading?) is causing this to be unstable if you
        // drag resize. Maximise etc works correctly
        pointer = renderer.renderCurrentPage(pointer);
        console.log("Current page re-rendered");
        console.log(pointer);
      });
    });
  </script>
</body>
</html>